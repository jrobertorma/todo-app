Dev log
04/02/2021
Start of the project, first commit

07/02/2021
Definition of objectives

08/02/2021
App design

09/02/2021
Research
Add react-router

10/02/2021
Files structure, react-router testing

11/02/2021
Adding empty components and navigation

12/02/2021
Adding more empty components, adding firebase

13/02/2021
Installing firebase, creating env vars

14/02/2021
Adding firebase config and using react context api to provide firebase to all app's components

15/02/2021
Adding firebase auth api to src\components\Firebase\firebase.js (untracked by git, it has the firebase config)

16/02/2021
Research and comments

17-20/02/2021
Adding signUp components

21-22/02/2021
Adding signIn components

23/02/2021
Adding signOut component

24-28/02/2021
Adding session handling

01/03/2021
Adding session handling

02/03/2021
Adding password management

03,04/03/2021
Adding password forget component

05-07/03/2021
Adding change password component

08-14/03/2021
Adding route protection

15/03/2021
Migrating to new hardware (T.T)

Be sure to have the '.env.development.local' file, I cloned the repo using git cli, and it partially worked but it keep throwing a 400 error on the API. 

I even created a new firebase project and added it to the env vars but didn't work, it is somehow related to the project keys, but I am not sure how (lol). 

So before cloning have a copy of the env vars file, here it is the snippet, it goes on the project's root folder.

REACT_APP_API_KEY=""
REACT_APP_AUTH_DOMAIN=""
REACT_APP_DATABASE_URL=""
REACT_APP_PROJECT_ID=""
REACT_APP_STORAGE_BUCKET=""
REACT_APP_MESSAGING_SENDER_ID=""
REACT_APP_APPID=""
REACT_APP_MEASUREMENTID=""

Then you can call them on the src\components\Firebase\firebase.js file, on the firebase config section.

Or just paste the config object you copied from your firebase console src\components\Firebase\firebase.js lol.

16-18/03/2021
Adding route protection

19/03/2021
Adding realtime database

21-23/03/2021
Adding realtime database CRUD components

24-31/03/2021
Adding roles support to users in db

01/04/2021
Adding browser's local storage support

02-06/04/2021
Adding social login

07-13/04/2021
Linking social accounts

14-20/04/2021
Creating notes and documentation of account linking

21-29/04/2021
Adding Email Verification

30/04/2021 - 06/05/2021
Adding Admin dashboard

07/05/2021 - 25/05/2021
Adding Core functionalities

PRIMARY GOALS
Build a todo-app from scratch, using react, redux and firebase.

What do you need to create the app?
	1. Initialize project

	2.1 Design user cases, user stories, or something to establish the data flows and needed operations
	2.2 App design (UI and functionalities)

	3.1 Build backend (it is going to be mostly firebase configuration)
	3.2 Build front-end (components)
	3.3 Wire back and front ends
	3.4 Test
	3.5 First MVP release

	4 Project documentation

2. APP DESIGN
	2.1 User cases
		There is going to be just one user (its name will be 'user', lol).
		'User' will have 3 basic user cases

		a) See to-do list: You call the firebase data and pass it to redux, you'll need to create a reducer, some actions and wire them to a data rendering component.
		b) Create a to-do list item: You will need a form, validate it (i guess we will use react-final-form) and use it to update the firebase data, I dont' know if redux is needed right here.
		c) Edit a to-do list item
			First you'll need the item data (fetching data from firebase)
			Then you'll need to show the data
			And lastly (trough a form) you will make the updates to firebase
			The delete item is going to be a similar operation

	2.2 UI and functionalities design
		The app will have two 'models' (in terms of design, not necessarily in code): User and Task
		
		USER
			The app will be able to make all CRUD operations to this 'model'
			This 'model' is required to implement the Login functionality
			I dont' know yet all the components this 'model' needs (I hope firebase will take care of most of them), but at least some sort 'Login' will be needed for this to work. 
		
		TASK
			Again, the app will be able to make all CRUD operations to this 'model'
			This will be the 'core' of the app (its a to-do app after all, lol)

			- TaskList
			- TaskCard
			- TaskForm (for both 'new task' and 'edit task' user cases)

3. APP DEVELOPMENT
	3.1 BACKEND: Firstly you need to check Firebase and React integrations to create the login, and all the 'users' CRUD. We are going to use this tutorial https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial (lol). And, in order for this stuff to work you need to add react-router to the app and play a little with some testing components. So we will be working simultaneously with the 'backend' and the frontend.

		3.1.1 Install firebase
			
			'yarn add firebase'

		3.1.2 Creating Firebase backend

			3.1.2.1 Create a firebase account and go to the console (https://console.firebase.google.com/)
			3.1.2.2 Create project, get configuration object, be careful lol (https://firebase.google.com/docs/web/setup)
			3.1.2.3 Create configuration variables, we are going to use the .env.development.local file to store the api keys, note that this is only for development, you should store production secret keys on the backend (https://stackoverflow.com/questions/48699820/how-do-i-hide-api-key-in-create-react-app)
			3.1.2.4 Add firebase support through react's context api (src\components\Firebase\context.js)
			3.1.2.5 Add firebase auth api support to the firebase class (on src\components\Firebase\firebase.js see the notes at the end of this file)

	3.2 FRONTEND: The stuff the user see and interacts with.
		3.2.1 Add react-router to the app (https://reactrouter.com/web/guides/quick-start)
			
			'yarn add react-router-dom'
			
			Then you can import the react-router components that deal with the routes and links.
			e.g.

				import {
				  BrowserRouter as Router,
				  Switch,
				  Route,
				  Link
				} from "react-router-dom";

		3.2.2 Create file structure for the components, make sure to follow a legible structure e.g. src/components/ {all the components}; src/containers; etc.

		3.2.3 Add react-router and write the routes constants and <Navigation> component (src\constants\routes.js and src\components\Navigation\index.js)

		3.2.4 Add dummy components for route testing (we will be updating them later)

		3.2.5 Create Auth Components

			3.2.5.1 SignUp components
			3.2.5.2 SignIn components
			3.2.5.3 SignOut components

	3.3 CONNECT FRONTEND AND BACKEND
		3.3.1 Set firebase context
		3.3.2 Add session handling
		3.3.3 Add password management
		3.3.4 Create protected routes
		3.3.5 Add realtime database support, when creating a new user also create a correspondent user object in the db
		3.3.6 Merge user state (from the auth API) with the user object (from the db)
		3.3.7 Use the merged user data to implement role based route protection
		3.3.8 Add social login functions, including merging accounts and email verification
		3.3.9 Update admin dashboard to edit users from the front-end
		3.3.10 Add the core functionalities

* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * N O T E S * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

---------------------- FIREBASE ----------------------

These are the contents of 'src\components\Firebase\firebase.js', the config file, it is important to note that you shouldn't use this kind of 
file on a production app, the best practice is to set the firebase connection through a backend (e.g. express).

import app from "firebase/app";
import 'firebase/auth';
import 'firebase/database';

const config = {
    apiKey:             process.env.REACT_APP_API_KEY,
    authDomain:         process.env.REACT_APP_AUTH_DOMAIN,
    databaseURL:        process.env.REACT_APP_DATABASE_URL,
    projectId:          process.env.REACT_APP_PROJECT_ID,
    storageBucket:      process.env.REACT_APP_STORAGE_BUCKET,
    messagingSenderId:  process.env.REACT_APP_MESSAGING_SENDER_ID,
    appId:              process.env.REACT_APP_APPID,
    measurementId:      process.env.REACT_APP_MEASUREMENTID 
};

class Firebase {
    constructor() {
        app.initializeApp(config);

        /* Helper */

        this.serverValue = app.database.ServerValue;
        this.emailAuthProvider = app.auth.EmailAuthProvider;
        
        this.auth = app.auth();
        this.db = app.database();

        //adding google social login provider
        this.googleProvider = new app.auth.GoogleAuthProvider();

        //adding fb social login provider
        this.facebookProvider = new app.auth.FacebookAuthProvider();
        
    }

    // *** Auth API ***

    doCreateUserWithEmailAndPassword = (email, password) =>
        this.auth.createUserWithEmailAndPassword(email, password);

    doSignInWithEmailAndPassword = (email, password) =>
        this.auth.signInWithEmailAndPassword(email, password);

    doSendEmailVerification = () =>
        this.auth.currentUser.sendEmailVerification({
            url: process.env.REACT_APP_CONFIRMATION_EMAIL_REDIRECT
        });

    //social login
    doSignInWithGoogle = () =>
        this.auth.signInWithPopup(this.googleProvider);

    doSignInWithFacebook = () => 
        this.auth.signInWithPopup(this.facebookProvider);

    doSignOut = () => this.auth.signOut();

    doPasswordReset = email => this.auth.sendPasswordResetEmail(email);

    doPasswordUpdate = password =>
        this.auth.currentUser.updatePassword(password);

    // *** Merge Auth and DB User API ***

    onAuthUserListener = (next, fallback) => {
        //listener (onAuthStateChanged) to know if the user is logged in
        this.auth.onAuthStateChanged( (authUser) => {
            //the user is logged in
            if (authUser) {
                this.user(authUser.uid)
                    .once('value')
                    .then(
                        //we call the db once() function to fetch the user data and then()
                        snapshot => {
                            //user db data (it is an object)
                            const dbUser = snapshot.val();

                            // if there are no roles, we add the default empty roles
                            if (!dbUser.roles) {
                                dbUser.roles = {};
                            }

                            // merge auth and db user, we called authUser from the listener, and now we are adding the db data
                            //to that state
                            authUser = {
                                uid: authUser.uid,
                                email: authUser.email,
                                emailVerified: authUser.emailVerified,
                                providerData: authUser.providerData,
                                ...dbUser,
                            };

                            //call the provided function, we pass the merged authUser object 
                            next(authUser);
                        });
            } else {
                fallback();
            }
        });
    }

    // *** User API ***

    user = uid => this.db.ref(`users/${uid}`);

    users = () => this.db.ref('users');

    // *** To-do list API ***

    todoItem = uid => this.db.ref(`todoItems/${uid}`);

    todoItems = () => this.db.ref('todoItems');
}

export default Firebase;

You also may want to add a firebase context to the app, so you don't need to create a firebase app instance for every component you use.
There is more info at https://reactjs.org/docs/context.html#reactcreatecontext.

We do that in the src\components\Firebase\context.js file as:

	import React from 'react';

	const FirebaseContext = React.createContext(null);

	export const withFirebase = Component => props => (
	    <FirebaseContext.Consumer>
	      {firebase => <Component {...props} firebase={firebase} />}
	    </FirebaseContext.Consumer>
	);

	export default FirebaseContext;

	export { withFirebase };

We can use the firebase context like this:

	const SignUpForm = withRouter(withFirebase(SignUpFormBase));

The SignUpFormBase component has this code on its onSubmit event handler:

	this.props.firebase
        .doCreateUserWithEmailAndPassword(email, passwordOne)
        .then(authUser => {
            this.setState({ ...INITIAL_STATE });
            this.props.history.push(ROUTES.HOME); /*redirect using history props 
            (we can do this because we added withRouter to the SignUpForm component (line 122))*/
        })
        .catch(error => {
            this.setState({ error });
        });

Here we are using the Auth API we defined at 'src\components\Firebase\firebase.js'. The call to doCreateUserWithEmailAndPassword triggers
the firebase this.auth.createUserWithEmailAndPassword(email, password); function (you can see the docs for this kind of auth method at: https://firebase.google.com/docs/auth/web/password-auth, here you'll find the functions we can use with firebase.auth() on 'src\components\Firebase\firebase.js').

---------------------- OTHER INTERESTING STUFF ABOUT SignUpFormBase ----------------------

I didn't bind the handlers and they still work!, and that is because we use arrow functions to define them 
(see: https://medium.com/@joespinelli_6190/using-arrow-functions-to-avoid-binding-this-in-react-5d7402eec64)

Also, as we are dealing with multiple input fields, the onChange handler makes use of the event.target.name var, 
we can read at the docs on this matter:

"When you need to handle multiple controlled input elements, you can add a name attribute to each element 
and let the handler function choose what to do based on the value of event.target.name."

The handler example is:

handleInputChange(event) {
	const target = event.target;
	const value = target.type === 'checkbox' ? target.checked : target.value;
	const name = target.name;

	this.setState({
  		[name]: value
	});
} 

see https://reactjs.org/docs/forms.html#handling-multiple-inputs.

---------------------- SESSION HANDLING ----------------------
Once we have the 'users loop' components (i.e. signin, login and logout), it is time to add session handling capabilities
to the app.

We need to let every component concerned on the session state, to know about the state of the loged in user.

From the book: "Logic regarding the current authenticated user needs to be stored and made accessible to other components."

Most developers use redux or mobx to achieve that.

But, we're going to use the react global state management instead.

So we need to track the authenticated user's state from the root component, and then pass it down to the children components 
that are interested in the logged in user (e.g. the nav, so you don't show the sign out button to a non logged in user). 

"Firebase offers a listener function to get the authenticated user from Firebase" (onAuthStateChanged), we use it in the App component.

See the src\components\App\index.js file.

We export app as a parameter of 'withFirebase', so we can use firebase functions within the component.

Next we use the componentDidMount function to add a listener to the firebase auth state (see the docs at: 
https://firebase.google.com/docs/auth/web/manage-users), this is called an 'observer'.

Inside the 'observer' function you can define what happens when a user is logged in and what happens when is not logged in.

We change the value of the 'authUser' state and pass it to the 'Navigation' component.

That component catches the 'authUser' value as a prop and then pass it as a condition to a ternary operator to render the logged or non loged navigation links.

It may be tedious to pass all the authUser state to every component through all the 'component tree', just for a couple of them to actually use it.

That is why we are going to use (again) the react context api to provide the session's state just to the components that use it.

First we create the context that is going to store the state (src\components\Session\context.js).

Then we create a withAuthentication class, that is going to manage the firebase auth state, this means that we will have to move all the authUser logic to this component from the App component (you know, all the 'observer' and 'onAuthStateChanged' stuff, see src\components\Session\withAuthentication.js).

Then we add the auth 'observer' to the context

	<AuthUserContext.Provider value={this.state.authUser}> //the context, we add the authUser as a prop to any component that calls withAuthentication
        <Component {...this.props} />
    </AuthUserContext.Provider>

Now we can use the authUser state anywhere, e.g. in src\components\Navigation\index.js

	<AuthUserContext.Consumer> //we call the context and then use its props
		{ 
	  		(authUser) =>  authUser ? <NavigationAuth /> : <NavigationNonAuth /> 
		}
	</AuthUserContext.Consumer>

It is important to note that we need to allow the component tree to use the function, therefore we added it in the App component's export:

	export default withAuthentication(App); //We can use withAuthentication in all the App's children

This pattern is called 'Higher order component', we use it too in the 'withFirebase' creation (https://reactjs.org/docs/higher-order-components.html)

---------------------- PASSWORD MANAGEMENT ----------------------
Now we can add the password management components. These are: passwordForget and changePassword.

In the passwordForget component we use a form, similar to the SignUpForm component.

First we define a PasswordForgetFormBase statefull class component, this component will be displaying the form, and will have the firebase API calls in its 
handlers.

Then we call it as argument of withFirebase(), and wrap it in a <div> as the PasswordForgetPage stateless function component (see src\components\PasswordForget\index.js).

We add a call to this component at the signInPage component (src\components\SignIn\index.js)

Now yo should be able to use the 'Forgot password' in the SignIn component. 

(It doesn't send the mail, you should see what's happening there)

Also there is the 'updatePassword' component, it behaves similarly to the other forms, we've done.

Use witFirebase, use a controlled form, validate the fields, on the onSubmit call the doPasswordUpdate() firebase's function, and update the state.

---------------------- ROUTE PROTECTION ----------------------
So far, if you type the route name on the browser, you will be able to see every component, even those wich are only for authenticated users to see.

We will fix that in this section.

First, we need to define the way we're going to use to decide wich components to show depending on the user.

It may be a 'broad-grained authorization' that just decides based on the state of the user (logged in or not).

Or we have 'fine-grained authorization', where we could have role-based or permission-based authorization.

We can implement the route protection in a way that allow us to be flexible between those auth patterns.

Again, we are going to use a HOC (Higher Order Component) to provide the authorization bussiness logic to the other components (see src\components\Session\withAuthorization.js).

It creates an 'observer' (https://firebase.google.com/docs/auth/web/manage-users) that checks the authUser state.

Then with a function (it is expected as a parameter) the HOC resolves if there is a logged user or not, and redirects to another component or renders the authorized component based on the function's response.

At the render method we call the AuthUserContext to be able to know the user state and return the Component (received as a parameter) or 'null'. 

https://stackoverflow.com/questions/784929/what-is-the-not-not-operator-in-javascript

Now, by calling the withAuthorization HOC, any component can be defined as a protected route.

Note that you have to provide a 'condtion' function such as:

	const condition = authUser => !!authUser; // '!!expression', returns the 'truthiness' of 'expression'

And addit to the HOC call like this:

	export default withAuthorization (condition)(AccountPage); //see src\components\Account\index.js

You can add a new protected route following that pattern, and even implement a more 'fine-grained' authorization rule, by changing the 'condition' function
logic, for instance to look for the user role.

---------------------- REALTIME DATABASE ----------------------
Firebase authentication API stores the users data and manages all of it's sensible information such as passwords and email addresses.

Right now, if we want for instance, a list of all the users we won't be able to do it, because Firebase authentication API does not allow us to.

And that is good, our users are protected. But we still may need to access the users data. If we want to add other 'entities' associated with the user (e.g. A note, a message, a book borrow history, etc) we need to access the users.

And we use Firebase realtime database in order to do that (it is not the same as the auth API).

We add this lines to the src\components\Firebase\firebase.js file (untracked by git, see the first note of this file)

	import 'firebase/database'; //NEW

	...

	class Firebase {
	    constructor() {
	        app.initializeApp(config);
	        this.auth = app.auth();
	        this.db = app.database(); //NEW
	    }

	...

		// *** User API *** NEW

	    user = uid = this.db.ref(`users/${uid}`);

	    users = () => this.db.ref('users');
	}

	export default Firebase;

As you may see, Firebase follows the REST phylosophy, where every entity (such as user, book, note, etc.) is associated with a URI (uniform resource identifier). In Firebase, the RESTful URI becomes a simple path, and the HTTP methods become Firebase’s API.

---------------------- USERS AND REALTIME DATABASE ----------------------
Now that we have linked our realtime database, we can add stuff to it. We wanted to manage users from the app, so we need to map the authUsers to the realtime database.

Wich means that we have to create a 'user' entity in the database when we create a user of firebase auth API. We can add a call to the db API after we create the user at src\components\SignUp\index.js

	this.props.firebase
    .user(authUser.user.uid)
    .set({
        username,
        email,
    });

To test the database indeed stores the users data we can create a component to show all the registered users.

That component should be accessible only to administrators, so we'll add it's route to the protected routes (NavigtionAuth at src/components/Navigation/index.js).

Then we can call the realtime database in the component.

---------------------- READING FROM REALTIME DATABASE ----------------------

All of this happens mostly in the src\components\Admin\index.js file.

The principal component is withFirebase(AdminPage), see how we call it as the withFirebase() argument, now we can call the firebase functions defined at src\components\Firebase\firebase.js (untracked by git, see its notes in this file).

In the docs we find HOW TO READ AND WRITE in the db (we already wrote at the SignUp component BTW).

https://firebase.google.com/docs/database/web/read-and-write, 

FIRST you need an instance of firebase.database.Reference, we have that covered calling the context and the reference.

	var database = firebase.database();

In our app we do that this way:

	this.props.firebase.users() //we can call this.props.firebase because the withFirebase(AdminPage) export

This is a call to the 'users()' method of the Firebase class. We defined it at the users API (notice how this method is defined at the src\components\Firebase\firebase.js file).

	users = () => this.db.ref('users'); //'this.db.ref' is analog to firebase.database() and 'firebase.database.Reference'

SECOND, to read data at a path and listen for changes, use the on() or once() methods of firebase.database.Reference to observe events. 

We will use the on() method because it keeps listening for changes in the db, once() as its name suggest, gets the data only once.

	The on() method listens for data changes at a particular location, this is the primary way to read data from a Database. 

	It gets two parameters: 'value', wich refers to the event we are listening to, it can be 'value', 'child_added', 'child_removed', etc. (See https://firebase.google.com/docs/reference/js/firebase.database.Reference#on for the full list). 

	And the second parameter is a callback function that will be triggered for the initial data and again whenever the data changes. We use off() to stop receiving updates.

	e.g.

		var starCountRef = firebase.database().ref('posts/' + postId + '/starCount');
		starCountRef.on('value', (snapshot) => {
		  const data = snapshot.val();
		  updateStarCount(postElement, data);
		});

	In our code we do this (componentDidMount is the best place to make API calls):

		this.props.firebase.users().on('value', snapshot => {
            this.setState({
                users: snapshot.val(), //the response of database API, a collection of 'user' objects
                loading: false,
            });
        });

    Later at the componentWillUnmount() statement we call the off() method

        this.props.firebase.users().off();

Now we can output the users data that is stored at the state. It is important to note that we stored it as the raw object returned by the firebase on() method. We need to build a dinamic component to show the data.

First we convert the object into an array

//Converting the users object stored in the state to an array
    const usersListArray = Object.keys(users).map( ( key ) => ({
        ...users[key],
        uid:key,
    }));

Object.keys returns an array of a given object's own enumerable property names, wich means we are getting the 'keys' of the object (duh, lol) e.g.

	const object1 = {
	  a: 'somestring',
	  b: 42,
	  c: false
	};

	console.log(Object.keys(object1)); // expected output: Array ["a", "b", "c"]

Now we run a map() function through the keys array, map returns a new array based on a loop that goes through every item of an array and does something (specified by a callback function) to that item (not always).

in this case we are passing every key of the users object to the callback wich returns a copy of the object item (notice the spread operator, i.e. ...users[key]) and a property uid
	
	...users[key], // copy of the object item with the key value
	uid: key //we add the key value as a new prop

e.g

	const object1 = {
	  a: {prop1: "one",prop2:"aaa"},
	  b: {prop1: "two",prop2:"bbb"},
	  c: {prop1: "three",prop2:"ccc"}
	};

	//Object.keys(object1), expected output: Array ["a", "b", "c"]
	objectArray = Object.keys(object1).map( ( key ) => ({ 
		...object1[key],
		uid:key,
	}));

	console.log(objectArray); 
	//expected output: Array [ {prop1: "one", prop2: "aaa", uid: "a"}, 
							   {prop1: "two", prop2: "bbb", uid: "b"}, 
							   {prop1: "three", prop2: "ccc", uid: "c"} ]

Now we have a new array containing the user object. We can use map() at the render function of a component to loop through this array and show the users data.

---------------------- USER ROLES AND PERMISSIONS ----------------------
It is common to want to assign user roles and allow users do stuff in your app based on them.

Firebase can manage user roles with its API. If we use it, it will difficult to migrate to other stacks if wee need to (e.g. traditional db server and backends).

A more flexible approach is to store the user roles in the user entities of the firebase realtime database. This way, you’ll have an easier time migrating away from Firebase.

We can do this in three stages:
	
	Assign roles to new users (a prop in the user entity)
		We added a new prop to the src\components\SignUp\index.js to know the 'role' of the new user, this includes state, fields, and handlers.
	
	Merge the authenticated user and database user so they can be authorized with their roles in the authorization higher-order component.
		Now we add role support to the database user object that is created when creating an AuthAPI user

		We have to merge the auth and db in the withAuthorization (to handle redirections) and withAuthentication (to handle the user's state) components.

		To do that we create the onAuthUserListener function in the src\components\Firebase\firebase.js file (untracked by git, see the FIREBASE section of this notes)

		// *** Merge Auth and DB User API ***

	    onAuthUserListener = (next, fallback) => {
	        this.auth.onAuthStateChanged( (authUser) => {
	            if (authUser) {
	                this.user(authUser.uid)
	                    .once('value')
	                    .then(
	                        snapshot => {
	                            const dbUser = snapshot.val();

	                            // default empty roles
	                            if (!dbUser.roles) {
	                                dbUser.roles = {};
	                            }

	                            // merge auth and db user
	                            authUser = {
	                                uid: authUser.uid,
	                                email: authUser.email,
	                                ...dbUser,
	                            };

	                            next(authUser);
	                        });
	            } else {
	                fallback();
	            }
	        });
	    }

	    notice how it expects two functions as parameters: next() and fallback(), they are 
		both callbacks (in form of arrow functions).

		It creates an observer to know if the user is logged in or not, and if it is logged in, we ask the db for the logged in user data
		and merge it with the authUser object on the state and pass it to the next() function.
		 
		If the user is not logged in it calls fallback() instead.

		Now we can call this function to know what to do in the withAuthorization (to handle redirections) and withAuthentication (to handle the user's state) components.

		withAuthorization.js

			componentDidMount() {
				//onAuthUserListener is defined at src\components\Firebase\firebase.js
			    this.listener = this.props.firebase.onAuthUserListener(
			        authUser => {
			            if(!condition(authUser)) {
			                this.props.history.push(ROUTES.SIGN_IN);
			            }
			        },
			        () => this.props.history.push(ROUTES.SIGN_IN),
			    );
			}

		withAuthentication.js

			componentDidMount() {
	            //onAuthUserListener is defined at src\components\Firebase\firebase.js
	            this.listener = this.props.firebase.onAuthUserListener(
	                authUser => {
	                    this.setState({ authUser });
	                },
	                () => {
	                    this.setState({ authUser: null });
	                },
	            )
	        }

	        We also update the user state in the context

	        <AuthUserContext.Provider value={this.state.authUser}>
                <Component {...this.props} />
            </AuthUserContext.Provider>


	Showcase a role authorization for one of our routes (e.g. only allowed for admin users).

		Now we can access the 'enriched' user object in any component invoked with the withAuthentication() HOC.
		'App' being one of them, wich uses react-router to render the components based on the nav input.

		The route we probably want to protect is the 'Admin' route, wich calls src\components\Admin\index.js.

		This component fetches the firebase users stored in the db (remember we create a 'copy' of every user created through the signUp component), and renders the data in a list.

		We only need to call the AuthUserContext (defined at withAuthentication) to know the logged user data, including its roles and render the nav component based on them.

		//Calling the AuthUserContext
		<AuthUserContext.Consumer>
	        { //deciding wich set of links will be rendered
	          //notice how we pass the authUser object to NavigationAuth in case someone is logged in 
	          (authUser) =>  authUser ? <NavigationAuth authUser={authUser}/> : <NavigationNonAuth /> 
	        }
	    </AuthUserContext.Consumer>

	    //Now we get a parameter (authUser)
	    const NavigationAuth = ({ authUser }) => {
		  return ( 
		    <ul>
		      <li>
		        <Link to={ROUTES.LANDING}>Landing</Link>
		      </li>
		      <li>
		        <Link to={ROUTES.HOME}>Home</Link>
		      </li>
		      <li>
		        <Link to={ROUTES.ACCOUNT}>Account</Link>
		      </li>
		        //and we see if there is a roles prop with the value of the constant (ROLES.ADMIN)
		        //and in case there is we render the link
		        { !!authUser.roles[ROLES.ADMIN] && (<li><Link to={ROUTES.ADMIN}>Admin</Link></li>) }
		        
		      <li>
		        <SignOutButton />
		      </li>
		    </ul>
		  );
		}

---------------------- ABOUT SOCIAL LOGIN ----------------------
We can add 'social login' as a sign up method to our app. Sometimes the user doesn't want to create a new account to use the app. With social login the user just needs to make some clicks to create an account on the app. This removes 'friction' to new users.

First we have to allow the desired social method in the firebase console, there are a lot of them, we can start with 'Google', so the user can create an account using it's Google account (see the docs at https://firebase.google.com/docs/auth/web/google-signin).

You go to the console (https://console.firebase.google.com) and go to the auth section, then sign-in methods, and activate 'Google'.

Afterward, we are able to implement the social login in the code.

	First we add the google auth handler to our 'interface' between react and firebase. i.e. the src\components\Firebase\firebase.js component (see its notes at the start of the notes). We define doSignInWithGoogle() function

		//social login
	    doSignInWithGoogle = () => {
	        this.auth.signInWithPopup(this.googleProvider);
	    }

	googleProvider was defined at the constructor

		//adding google social login
        this.googleProvider = new app.auth.GoogleAuthProvider();

	Then we can call it in our SignIn component (src\components\SignIn\index.js)

		class SignInGoogleBase extends Component {
		    constructor(props){
		        super(props);

		        this.state = { error: null }
		    }

		    //calling the doSignInWithGoogle() function defined at firebase.js
		    onSubmit = (event) => {
		        this.props.firebase
		            .doSignInWithGoogle() //here is the magic
		            .then( socialAuthUser => {
		                //add user to the db too
		                this.props.firebase
		                    .user(socialAuthUser.user.uid)
		                    .set({
		                        username: socialAuthUser.user.displayName,
		                        email: socialAuthUser.user.email,
		                        roles: [],
		                    })
		                    .then(() => {
		                        this.setState({ error: null });
		                        this.props.history.push(ROUTES.HOME);
		                    })
		                    //if there are any error
		                    .catch(error => {
		                        this.setState({ error });
		                    })
		            })
		            .catch(error => {
		                this.setState({ error });
		            })
		            
		        event.preventDefault();
		    };

		    render() {
		        const { error } = this.state;

		        return (
		            <form onSubmit={this.onSubmit}>
		                <button type="submit">Sign In with Google</button>

		                {error && <p>{error.message}</p>}
		            </form>
		        );
		    }
		}

Another popular sign in method is 'Facebook'. To enable it we should set some things before.
	
	First we need to create an account on https://developers.facebook.com/
	Then we can create a 'new app', you should choose the 'Create connected experiences' (or something like that lol) radio button.
	We need to copy the app id and secret from the settings > basic panel
	Now on the firebase auth console we can activate the 'FB' sign in method, we use the id and secret we copied before, also copy the callback code, we will use it later.
	We also need to enable the 'login product' for the FB app (its on the dashboard), then we go to settings (without touching any login setting) and paste the OAuth redirect URI that we got when enabling the Facebook Sign In Method in Firebase (see https://www.robinwieruch.de/firebase-facebook-login).

	Now we can add the signIn method to the code.

	Again, we add the provider in the firebase.js file

		//adding fb social login provider
        this.facebookProvider = new app.auth.FacebookAuthProvider();

    And call it in a new function

    	doSignInWithFacebook = () => 
        this.auth.signInWithPopup(this.facebookProvider);

    Then we call that function as a firebase.prop in a new form (see src\components\SignIn\index.js)

    	class SignInFacebookBase extends Component {
		    constructor(props) {
		        super(props);
		        this.state = { error: null }
		    }

		    onSubmit = event => {
		        this.props.firebase
		            .doSignInWithFacebook()
		            .then( socialAuthUser => {
		                this.props.firebase
		                    .user(socialAuthUser.user.uid)
		                    .set({
		                        username: socialAuthUser.additionalUserInfo.profile.name,
		                        email: socialAuthUser.additionalUserInfo.profile.email,
		                        roles: [],
		                    })
		                    .then(
		                        () => {
		                            this.setState({ error: null });
		                            this.props.history.push(ROUTES.HOME);
		                        }
		                    )
		                    .catch(
		                        error => {
		                            this.setState(error);
		                        }
		                    )
		            })
		            .catch(
		                error => {
		                    this.setState({error});
		                }
		            );

		        event.preventDefault();
		    }

		    render() { 
		        const { error } = this.state;
		        return ( 
		            <form onSubmit={this.onSubmit}>
		                <button type="submit" >Sign In with Facebook</button>
		                { error && <p>{error.message}</p> }
		            </form>
		         );
		    }
		}

Now we need to link all social accounts when creating a user in the app. This means we can create an account with our email, or with a Google or Facebook account with the same email. And no matter wich sign-in method the user takes, the account should be the same.

	First we need to prevent the user from signing in with another account when there is an account associated to the email address (firebase > console > auth > signin method tab).

	Then we wil catch the error created when trying to signIn with a social account that has an already created mail registered in the app. In src\components\SignIn\index.js we catch the error and show it to the user.

	We do the same with the signUp component. The user might use a social login first and later attempt to sign up with an email address (email/password sign up) that has been used by the social login already, we should cath this kind of case (see the src\components\SignUp\index.js component).

	Now users can use the same mail address for different sign-in methods. Now we will add an area to manage and activate/deactivate all the sign-in methods to the Account component (see the src\components\Account\index.js component). The component has a list of all the available sign in methods and fetches the active methods for the authenticated user, then compares both lists (arrays) and based on its state (active or not active) displays a button to activate/link each of the sign in methods or to unlink/deactivate them, depending on the aforementioned state.

IMPORTANT NOTES: linkAndRetrieveDataWithCredential is deprecated, we should use other function instead. See src\components\Account\index.js

---------------------- ABOUT EMAIL VERIFICATION ----------------------
When the user creates an account with the email address and password method, we have no way to know if the address exist or if it doesn't.

Firebase provides a method to implement email verification, so we can be sure the user has access to the provided email address.

	First we add the method to the firebase class 

		src\components\Firebase\firebase.js

			doSendEmailVerification = () =>
	        this.auth.currentUser.sendEmailVerification({
	            url: process.env.REACT_APP_CONFIRMATION_EMAIL_REDIRECT
	        });

      	Notice how we call a new environment constant. We could use the url directly, but by using the environmental constants
      	you can switch between .env files and make this parameter dynamic.

  		We add to the .env.development.local file

      		REACT_APP_CONFIRMATION_EMAIL_REDIRECT=http://localhost:3000

	Then we call the method when the app creates new users for that signUp method
		Because that is the best place to guide users to the email verification

		We add this line after the user creation on the db (this is at the onSubmit handler of the <SignUpFormBase /> component
		in the src\components\SignUp\index.js)

			.then(() => {
		    	return this.props.firebase.doSendEmailVerification();
		    })

	Lastly we add route protection to allow users to use the app only if they have verified their email address.
		First we need to know if the user has a verified email.
		In order to do that, we add a state to store that value on the db, when creating the user on the onAuthUserListener()
		method of the src\components\Firebase\firebase.js file.

			// merge auth and db user
            authUser = {
              	uid: authUser.uid,
              	email: authUser.email,
              	emailVerified: authUser.emailVerified,
              	providerData: authUser.providerData,
              	...dbUser,
            };

        Then we create a new HOC that has access to Firebase and the authenticated user (src\components\Session\withEmailVerification.js)
        	The component will check if the user has verified the email address and based on that will render the passed component (remember
        	a HOC recieves a component and re-renders after doing something) or a button to resend the verification link.

        Finally we need to call the withEmailVerification HOC in the components/routes that need to be protected.
        	src/components/Session/index.js (to make the HOC available to the other components)
        	src/components/Home/index.js
        	src/components/Admin/index.js
        	src/components/Account/index.js

        /* The emailVerified state is not in the realtime database, need to know why T.T: I think it may be related with the AuthUserContext. when
        	I try to print the authUser object in the src\components\Session\withEmailVerification.js component the app displays an error, it can't 
        	find the authUser var, well, we'll check that later lol*/

---------------------- EXTENDING ADMIN PAGE ----------------------
Right now, the src\components\Admin\index.js component only shows a list of users. Now we will create a dashboard for the admins, that besides displaying all the registered users, will allow some other functionalities.

	First we define a new child route on the src\constants\routes.js file

		export const ADMIN_DETAILS = '/admin/:id'

		As you can see, we added a param. i.e. a placeholder for an 'id', when the router gets a route like /admin/sdadasd, it will call this route.

	Then we create a new list component to render a link for each user at the admin component (src\components\Admin\index.js), the route of each of them will follow the ADMIN_DETAILS format. The UserListBase component fetchs all the users stored on firebase and usign a map, renders them within a list, including the link for the user detail.  
		
		...
		<span>
            <Link to = {{ 
                pathname: `${ROUTES.ADMIN}/${user.uid}`, 
                state: { user }, 
            }}>
                Details
            </Link>
        </span>
        ...

    The router (defined at AdminPage component), will return the UserItem component when a route like '/admin/:id' is called.

    	...
	    <Switch>
	        <Route exact path={ROUTES.ADMIN_DETAILS} component={UserItem} />
	        <Route path={ROUTES.ADMIN}>
	            <UserList />
	        </Route>
	    </Switch>
	    ...

	The component gets the user (see the <Link> component) and the user.uid prop, and uses them to render the user details, including a link for the password reset firebase function.

	UserItemBase component

		...
		render() {
		    const { user, loading } = this.state;

		    return (
		      <div>
		        <h2>User ({this.props.match.params.id})</h2>
		        {loading && <div>Loading ...</div>}

		        {user && (
		          <div>
		            <span>
		              <strong>ID:</strong> {user.uid}
		            </span>
		            <span>
		              <strong>E-Mail:</strong> {user.email}
		            </span>
		            <span>
		              <strong>Username:</strong> {user.username}
		            </span>
		            <span>
		              <button
		                type="button"
		                onClick={this.onSendPasswordResetEmail}
		              >
		                Send Password Reset
		              </button>
		            </span>
		          </div>
		        )}
		      </div>
		    );
		  }
		  ...

---------------------- CORE FUNCTIONALITIES ----------------------
We have a Login and all the components for the 'user' object, we can lock components based on wether the user is logged in or if it has the permissions based on the roles stored in the realtime database.

This could be the base for any app you want to build using firebase and react, robinwieruch also has other versions of this 'scafold app' (including one with redux).

Now we can add the other entities you will need for any of your apps, a 'book', a 'movie', or a 'note' entity (or all of them if you need them).

DEFINING THE API
The Firebase class is the bridge between the app and the Firebase API. We instantiate it once and then pass it to every component that needs it using the React's Context API. There we can define all APIs to connect both parties. We've done that with the authentication API and the realtime database API (see comments on the class methods).

Now we can define a new API for the entity. This is a todolist app, so it will be a 'todolistitem' entity. The items will be stored in the realtime database.

src\components\Firebase\firebase.js

	...
	// *** To-do list API ***

    todoItem = uid => this.db.ref(`todoItems/${uid}`);

    todoItems = () => this.db.ref('todoItems');
    ...

todoItems will be readable and writable on these endpoints. We will create a new note and fetch all the todoItems with the 'todoItems' endpoint, and edit and remove notes with the 'todoItems/:todoItemId' endpoint.

CORE FUNCTIONALITIES
The HomePage is the best place to show all the user's todoItems, because is a protected route and is easy to access.

So we'll add a <TodoList /> component that will render all the 'todoItems', the children component that fetches and renders the todoItems is TodoListBase, it has a firebase listener (see the .on() method) attached to the 'todoItems' entities.

Then we add a form to create new 'todoItems', the onSubmit function calls the .push() method, so it creates a new record with a unique ID.

The app will store only one todo list with a lot of todo list items (I just figured that out XD).

The TodoListBase component also gets the authUser object using the react context API to only display the items created by the logged user.

There is a handler to remove list items and to update a list item.

TodoListBase pass all the handlers and list items to the ItemsList component, that component only maps the todoListItems and calls the ListItem component passing the same handlers to that component.

ListItem displays the list item and some buttons (with a lot of conditional rendering) to implement the edit and delete functionalities.

And that's it, we still can add some color and improve the UI but the basic functionalities are working :). 

---------------------- UI IMPROVEMENTS ----------------------
Installed 
	yarn add @material-ui/core
	npm install @fontsource/roboto
	yarn add @material-ui/icons

NAVIGATION
I liked the <Drawer/> component, it displays a menu button, when clicked displays a sidebar with styled links.

How to convert the basic nav into a mui <Drawer/>?
The nav structure starts in the src\components\App\index.js component
	
	<Router>
      <Container>

        <Navigation />

        <hr />

        <Switch>

          { /* ROUTES */ }

        </Switch>

      </Container>
    </Router>

The <Navigation /> component has the following structure:
	
	if there is a logged in user
		<NavigationAuth />
	else
		<NavigationNonAuth />

	Each Navigation component returns an unordered list (<ul>) with <Link /> components as list items (<li>)

	<ul>
      <li>
        <Link to={ROUTES.LANDING}>Landing</Link>
      </li>

      ...

    </ul>

In the docs the <Drawer/> example has this structure (you could call this a lame kind of 'pseudocode' lol)

	{/* IMPORTS */} YA

	{/* drawerWidth CONST*/} YA

	{/* useStyles CONST, that uses the makeStyles() API method to create the styles for the components */} YA

	{/* PersistentDrawerLeft component */}

The PersistentDrawerLeft component has the following structure

	{/* styles and theme constants */} YA

	{/* hooks and handler functions */} YA

	{/* return statement 

			AppBar component
				IconButton with the openDrawer handler

			Drawer component
				List component
					ListItem component
	*/}

Note about react Hooks
  /**
  * A hook is a function that allows a component to use some
  * react functionality, e.g. useState() is a hook that lets you
  * use 'react states' within a function component (in the old times
  * you would need to rewrite a stateless functional component into
  * a class stateful component in order to use react states)
  * 
  * so we call the useState() hook to handle the drawer state
  **/

We'll add the styles, hooks and handlers (and the wrapper) into the src\components\App\index.js component
We'll add the List and ListItem components to the NavigationAuth and NavigationNonAuth components
	
	{/* all the drawer stuff */}
	...

	{/* return statement 

			AppBar component
				IconButton with the openDrawer handler

			Drawer component
				<Navigation />
	*/}

	...
	{/* all the drawer stuff */}

At the <Navigation/> component we used mui 'composition' to render a good looking button that calls a react-router-dom link

	const Navigation = ({toolbarHandler}) => {
	  return (
	    <div>
	      <AuthUserContext.Consumer>
	        { 
	          (authUser) =>  authUser ? 
	            <NavigationAuth authUser={authUser} toolbarHandler={toolbarHandler}/> : 
	            <NavigationNonAuth toolbarHandler={toolbarHandler}/> 
	        }
	      </AuthUserContext.Consumer>
	    </div>
	  );
	}

Notice we also pass the toolbarHandler argument to the component and pass it again to both 'Navigation' components. Those components render the nav links:
	
	<ListItem button component={Link} to={ROUTES.LANDING} onClick={toolbarHandler("Landing")}>
		<ListItemIcon> <CallToActionIcon /> </ListItemIcon>
		<ListItemText primary="Landing" />
	</ListItem>

They display an icon, a text and use the 'composition' (see the 'component={Link}' prop) so it has the react-router-dom function available to the onClick listener (this is implicit), we also define an onClick handler thar is the previously passed toolbarHandler that gets a string as an argument.

The handler was defined at the src\components\App\index.js <App /> component

First a new state using the useState Hook was defined (see the docs at https://reactjs.org/docs/hooks-state.html)

	 const [toolbarText, setToolbarText] = React.useState("");

Basically with this hook you can use state without needing to rewrite a functional component into a class.

When using the hook you name the state var and its state handler (toolbarText and setToolbarText in this case), and the default value for the state (the empty quotes).

Then you can use the set handler anywhere

	const toolbarHandler = newToolbarText => () => {
		setToolbarText(newToolbarText);
	}

And use the state as usual.
	
	<Typography variant="h6" noWrap>
    	{toolbarText}
    </Typography>

https://material-ui.com/components/drawers/
https://dev.to/rossanodan/building-a-navigation-drawer-with-material-ui-and-react-router-dom-1j6l
https://material-ui.com/guides/composition/

COOL LINKS:
https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial
https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial#firebase-in-react-setup

https://firebase.google.com/docs/auth/web/firebaseui?authuser=1
https://firebase.google.com/docs/auth/web/auth-state-persistence
https://firebase.google.com/docs/database/web/read-and-write#web_value_events
https://firebase.google.com/docs/database/admin/save-data

https://developers.facebook.com/

https://material-ui.com/getting-started/installation/